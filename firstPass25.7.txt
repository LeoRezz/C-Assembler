#include "firstPass.h"
#include "symbolTable.h"
#define MAX_LINE 82
#define MAX_LABEL_LENGTH 31

const char *reserved_word[16] = {
    "mov", "cmp", "add", "sub", "lea",
    "clr", "not", "inc", "dec",
    "jmp", "bne", "red", "prn",
    "jsr", "rts", "stop"};

/* Global state, Instruction and Data count*/
int IC = 0;
int DC = 0;
int current_line = 0;

/* prototypes */
void first_pass(FILE *input_file);

int main(int argc, char *argv[]) {
    FILE *input_file = NULL;
    char *file_name = NULL;
    int lineNum = -1, colNum = -1;
    file_name = strdup("temp");
    strcat(file_name, ".ob");
    input_file = fopen(file_name, "r");

    /* fopen() return NULL if unable to open file in given mode. */
    if (!input_file) {
        printf("Failed to open input file: %s\n", argv[1]);
        free(file_name);
        exit(EXIT_FAILURE);
    }
    initSymbolTable();
    first_pass(input_file);
    printTable();
    freeSymbolTable();
}

void first_pass(FILE *input_file) {
    char line[MAX_LINE];

    while (fgets(line, MAX_LINE, input_file) != NULL) {
        current_line++;
        parse_line(line);
    }

    /* After processing all lines
    update_data_symbols(); */
}

void parse_line(char *line) {
    char *token;
    char label[MAX_LABEL_LENGTH] = {0};

    printf("Parsing line: %s\n", line);

    token = strtok(line, " \t\n");

    /* Check if the line starts with a label */
    if (token && token[strlen(token) - 1] == ':') {
        strncpy(label, token, strlen(token) - 1);
        label[strlen(token) - 1] = '\0'; // Remove the ':'
        token = strtok(NULL, " \t\n");   // Move to next token
        printf("Label is: %s\n", label);
    }

    // Now token is either an instruction or a directive
    if (!token) {
        // Line only contained a label or was empty
        printf("Line is empty or contains only a label\n");
        return;
    }

    printf("Token is: %s\n", token);

    if (is_instruction(token)) {
        handle_instruction(token, label);
    } else if (is_directive(token)) {
        handle_directive(token, label);
    } else {
        printf("Error in line %d: Unknown token '%s'\n", current_line, token);
    }
}

void handle_instruction(char *token, char *label) {
    if (token == NULL || label == NULL) {
        // Handle error: null pointer passed
        printf("Error in handle_instruction: null pointer passed\n");
        return;
    }

    if (label[0] != '\0') {
        addSymbol(label, IC, SYMBOL_CODE);
    }

    int instruction_length = get_instruction_length(token);
    if (instruction_length == -1) {
        // Handle error: invalid instruction
        printf("Error in handle_instruction: invalid instruction '%s'\n", token);
        return;
    }

    // Parse operands and do any necessary processing
    IC += instruction_length;
}

void handle_directive(char *token, char *label) {
    if (strcmp(token, ".data") == 0) {
        if (label[0] != '\0') {
            addSymbol(label, DC, SYMBOL_DATA);
        }
        handle_data_directive();
    } else if (strcmp(token, ".string") == 0) {
        if (label[0] != '\0') {
            addSymbol(label, DC, SYMBOL_DATA);
        }
        handle_string_directive();
    } else if (strcmp(token, ".entry") == 0) {
        handle_entry_directive();
    } else if (strcmp(token, ".extern") == 0) {
        handle_extern_directive();
    }
}

void handle_data_directive() {
    char *token;
    while ((token = strtok(NULL, " ,\t\n")) != NULL) {
        // Convert token to integer and store in data array
        // Increment DC
    }
}

void handle_string_directive() {
    char *token = strtok(NULL, "\"\n"); // Get the string content
    if (token) {
        // Store each character in data array
        // Increment DC for each character plus null terminator
    }
}

void handle_entry_directive() {
    // This might be handled in the second pass
    // For now, just note that this symbol is an entry point
}

void handle_extern_directive() {
    char *token = strtok(NULL, " \t\n");
    if (token) {
        addSymbol(token, 0, SYMBOL_EXTERNAL);
    }
}

int get_instruction_length(char *token) {
    int i;
    for (i = 0; i < 16; i++) {
        if (strncmp(token, reserved_word[i], strlen(reserved_word[i])) == 0) {
            return 2; // fix this
        }
    }

    return 0;
}

int is_instruction(char *token) {

    return 1;
}

int is_directive(char *token) {
    return 0;
}